# 数据的表示

## 1. 进制转换

|     进制      | 数码                         | 基数  | 位权  |
| :-----------: | ---------------------------- | :---: | :---: |
|  十进制（D）  | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 |  10   | 10^k  |
|  二进制（B）  | 0, 1                         |   2   |  2^k  |
|  八进制（Q）  | 0, 1, 2, 3, 4, 5, 6, 7       |   8   |  8^k  |
| 十六进制（H） | 0 ~ 9, A, B, C, D, E, F      |  16   | 16^k  |

### 1.1 按权展开法（R 进制 → 十进制）

**R 进制转十进制**使用**按权展开法**，具体操作方式为：

1. 将 R 进制数的每一位数值用 `R^k` 形式表示，即幂的底数是 R，指数为 k，k
与该位和小数点之间的距离有关；
2. 当该位位于小数点**左边**，k 值是该位和小数点之间数码的个数；
3. 当该位位于小数点**右边**，k 值是负值，其**绝对值**是该位和小数点之间数码的个数加 1。

示例：

1. 二进制 `10100.01 = 1 * 2^4 + 1 * 2^2 + 1 * 2^-2 = 20.25`
2. 七进制 `604.01 = 6 * 7^2 + 4 * 7^0 + 1 * 7^-2 = 298.02`

### 1.2 短除法（十进制 → R 进制）

**十进制转 R 进制**使用短除法（除基取余法），具体操作方式为：

1. 从上向下除，记录每次除以 R 的余数；
2. **从下向上连接余数**，得到最终结果。

**示例 1**：将 `94` 转换成二进制，最终结果是：`1011110`。

```txt
2 | 94
2 | 47 → 余 0
2 | 23 → 余 1
2 | 11 → 余 1
2 | 5 → 余 1
2 | 2 → 余 1
2 | 1 → 余 0
  | 0 → 余 1
```

**示例 2**：将 `57` 转换成二进制，最终结果是：`111001`。

```txt
2 | 57
2 | 28 → 余 1
2 | 14 → 余 0
2 | 7 → 余 0
2 | 3 → 余 1
2 | 1 → 余 1
  | 0 → 余 1
```

### 1.2 二进制转八进制或十六进制

操作方式：

1. **从右向左分组**，转 8 进制则每 3 位一组，转 16 进制则每 4 位一组；
2. **从左向右计算**，将**分组后的 2 进制的 1/0** 计算为对应进制的数值，并得到最终结果。

示例：

1. `10001110` → `10` `001` `110` → `216`
2. `10001110` → `1000` `1110` → `8E`

## 2. 码制（原码 / 反码 / 补码 / 移码）

1. **原码**：最高位是符号位，其余低位表示数值的绝对值（**0 表示正数，1 表示负数**）
2. **反码**：正数的反码与原码相同，负数的反码是其**绝对值按位取反**（符号位不变）
3. **补码**：正数的补码与原码相同，负数的补码是其**反码末位加 1** （符号位不变）
4. **移码**：补码的符号位按位取反

|      |     1     |    -1     |   1 - 1   |
| ---- | :-------: | :-------: | :-------: |
| 原码 | 0000 0001 | 1000 0001 | 1000 0010 |
| 反码 | 0000 0001 | 1111 1110 | 1111 1111 |
| 补码 | 0000 0001 | 1111 1111 | 0000 0000 |
| 移码 | 1000 0001 | 0111 1111 | 1000 0000 |

> 提示：在实际计算时，要使用**补码**计算。

| 码制 | 定点整数                        | 定点小数                           | 数码个数 |
| ---- | ------------------------------- | ---------------------------------- | -------- |
| 原码 | -(2^(n-1) - 1) ~ +(2^(n-1) - 1) | -(1 - 2^-(n-1)) ~ + (1 - 2^-(n-1)) | 2^n - 1  |
| 反码 | -(2^(n-1) - 1) ~ +(2^(n-1) - 1) | -(1 - 2^-(n-1)) ~ + (1 - 2^-(n-1)) | 2^n - 1  |
| 补码 | -2^(n-1) ~ +(2^(n-1) - 1)       | -1 ~ +(1 - 2^-(n-1))               | 2^n      |
| 移码 | -2^(n-1) ~ +(2^(n-1) - 1)       | -1 ~ +(1 - 2^-(n-1))               | 2^n      |

1. 定点整数
   1. 当 `n = 8`，也就是一共 8 个数位
   2. 原码：十进制 `-127 ~ +127` / 二进制 `1111 1111 ~ 0111 1111`
   3. 补码：`1000 0001 ~ 0111 1111`
   4. **其中 `-128` 的补码为 `1000 0000`（`-0`）是人为规定**，最高位既做符号位，也做数值位
2. 定点小数
   1. 当 `n = 8`，也就是一共 8 个数位
   2. 原码：`-0.111 1111 ~ +0.111 1111`
   3. 补码：`-0.000 0001 ~ +0.111 1111`
   4. **其中 `-1` 的补码为 `1000 0000`（`-0`）是人为规定**，最高位既做符号位，也做数值位
3. 提示：在补码中统一规定，`0` 用 `+0` 表示

> 考点：会考取值范围。

### 码制例题（原码 / 反码 / 补码 / 移码）

**题目 1**：如果 `2X` 的补码是 `90H`，那么 `X` 的真值是（ B ）。

1. A. `72`
2. B. `-56`
3. C. `56`
4. D. `111`

解题：

```txt
1. 90H = 1001 0000 B
2. 反码：1000 1111 B
3. 原码：1111 0000 B → -(64 + 32 + 16) = -112
4. -112 / 2 = -56
```

**题目 2**：采用 n 位补码（包含一个符号位）表示数据，可以直接表示数值（ D ）。

1. A. 2^n
2. B. -2^n
3. C. 2^(n-1)
4. D. -2^(n-1)

## 3. 浮点数的表示

1. 浮点数表示：N = 尾数 \* 基数^指数
2. 运算过程：对阶 → 尾数计算 → 结果格式化
3. 特点：
   1. 通常**尾数用补码**，**阶码用移码**
   2. **阶码**的位数决定数的表示范围，尾数越多范围越大
   3. **尾数**的位数决定输的有效精读，尾数越多精读越高
   4. **对阶时，小数向大数看齐**
   5. 对阶是通过**较小数的尾数右移**实现的

示例 1：十进制示例 `0.12 * 10^2 + 1.23 * 10^3`

```txt
1. 对阶：0.012 * 10^3 + 1.23 * 10^3
2. 位数计算：1.242 * 10^3
3. 结果：1242
```

### 浮点数的表示例题

**题目 1**：浮点数能够表示的数的范围是由其（ B ）的位数決定的。

1. A. 尾数
2. B. 阶码
3. C. 数符
4. D. 阶符

**题目 2**：以下关于两个浮点数相加运算的叙述中，正确的是（ B ）。

1. A. 首先进行对阶，阶码大的向阶码小的对齐
2. B. 首先进行对阶，阶码小的向阶码大的对齐
3. C. 不需要对阶，直接将尾数相加
4. D. 不需要对阶，直接将阶码相加

**题目 3**：某种机器的浮点数表示格式如下（允许非规格化表示）。若阶码以补码表示，尾数以原码表示，则 `1000 1000 0000 0001` 表示的浮点数是 （ B ）。其中：

- 阶符占据 1 位，阶码部分占据 4 位，共计 5 位。
- 数符占据 1 位，尾数部分占据 10 位，共计 11 位。
- 阶码部分在前，尾数部分在后

1. A. 2^-16 \* 2^-10
2. B. 2^-15 \* 2^-10
3. C. 2^-16 \* (1 - 2^-10)
4. D. 2^-15 \* (1 - 2^-10)

```txt
1. 划分阶码和尾码：1 0001 0 0000000001
2. 阶码：补码 1 0001 → 反码 1 0000 → 原码 1 1111 → 十进制 -15
3. 尾码：原码 0 0000000001 → 十进制 2 ^ -10
```

## 4. 逻辑运算

### 4.1 关系运算符

- 关系运算符及优先次序
  - 优先级高
    - `<` 小于
    - `<=` 小于或等于
    - `>` 大于
    - `>=` 大于或等于
  - 优先级低
    - `==` 等于
    - `!=` 不等于
  - 说明：
    - **关系运算符**的优先级低于**算术运算符**
    - **关系运算符**的优先级高于**赋值运算符**

### 4.2 逻辑运算符

- 逻辑变量之间的运算称为逻辑运算，二进制数 1 和 0 在逻辑上可以代表 “真”与“假”
- 逻辑运算：
  - **逻辑或**（`||`、`+`、`U`、`V`、`OR`）：连接的两个逻辑值**全 0 时才取 0**；
  - **逻辑与**(`&&`、`*`、`•`、`Π`、`Λ`、`AND`）：连接的两个逻辑值**全 1 时才取 1**；
  - **逻辑异或**(`⊕`、`XOR`）：连接的两个逻辑值**不相同时才取 1，相同则取 0**；
  - **逻辑非**(`!`、`￢`、`~`、`NOT`，`ˉ`）：将原逻辑值取反即可。

- 真值表：描述一个逻辑表达式与其变量之间的关系

  |   A   |   B   |  A+B  |  A*B  |  A⊕B  |  !A   |
  | :---: | :---: | :---: | :---: | :---: | :---: |
  |   0   |   0   |   0   |   0   |   0   |   1   |
  |   0   |   1   |   1   |   0   |   1   |   1   |
  |   1   |   0   |   1   |   0   |   1   |   0   |
  |   1   |   1   |   1   |   1   |   0   |   0   |

- 优先级：
  - `!`（非） > `&&`（与） > `||` （或）

- 逻辑运算符中的 `&&` 和 `||` 低于关系运算符，`!` 高于算数运算符

> 结论：`!` > 算术运算符 > 关系运算符 > `&&` > `||` > 赋值运算符。

#### 短路原则

短路原则：**在逻辑表达式的求解中，并不是所有的逻辑运算符都要被执行**。

- **例 1**：`a && b && c` 只有 `a` 为真时，才需要判断 b 的值；
- **例 2**：`a || b || c` 只要 `a` 为真，就不必判断 b 和 c 的值。
- **例 3**：`(m = a > b) && (n = c > d)`
  - 当 `a = 1`、`b = 2`、`c = 3`、`d = 4`，`m` 和 `n` 的原值为 `1`；
  - 由于 `a > b` 的值为 `0`，因此 `m = 0`；
  - 而 `n = c > d` 不被执行，因此 `n` 的值不是 `0` 而仍保持原值 `1`。

> 结论：逻辑与短路 → 一个假 / 逻辑或短路 → 一个真。

#### 短路原则例题

**题目 1**：逻辑表达式求值时常采用短路计算方式。`&＆`、`||`、`!` 分别表示**逻辑与**、**逻辑或**、**非运算**，`&&`、`||` 为左结合，`！` 为右结合，优先级从高到低为 `!`、`&&`、`||`。对逻辑表达式 `x && (y || !z)` 进行短路计算方式求值时，（ B ）。

1. A. x 为真，则整个表达式的值即为真，不需要计算 y 和 z 的值
2. B. x 为假，则整个表达式的值即为假，不需要计算 y 和 z 的值
3. C. x 为真，再根据 z 的值决定是否需要计算 y 的值
4. D. x 为假，再根据 y 的值決定是否需要计算 z 的值

## 5. 校验码

### 5.1 校验码基础知识

- **码字**：二进制能够表示数据的个数，例如：4 位二进制表示 16 种状态，则有 16 个不同的码字；
- **码距**：任何一种编码都由许多码字构成，任意两个码字之间最少变化的二进制位数就称为数据校验码的码距，例如：
  - `0000` 与 `0001` 的码距是 `1`；
  - `0010` 与 `1001` 的码距是 `3`。

> 结论：把两个编码的码字**按位进行异或运算**，然后找出 `1` 的个数，就是码距。

### 5.2 奇偶校验码

- 作用：奇偶校验码，可检查**奇数个数据位**的错误，不可纠错。
- **奇偶校验码**的编码方法是：由若干位有效信息（如一个字节），再加上一个二进制位（校验位）组成校验码；
  - **奇校验**：整个校验码（有效**信息位**和**校验位**）中 `1` 的个数为奇数；
  - **偶校验**：整个校验码（有效**信息位**和**校验位**）中 `1` 的个数为偶数。

#### 奇偶校验码例题

**题目 1**：以下关于采用一位奇校验方法的叙述中，正确的是（ C ）。

1. A. 若所有奇数位出错，则可以检测出该错误但无法纠正错误
2. B. 若所有偶数位出错，则可以检测出该错误并加以纠正
3. C. 若有奇数个数据位出错，则可以检测出该错误但无法纠正错误
4. D. 若有偶数个数据位出错，则可以检测出该错误并加以纠正

### 5.3 CRC 循环冗余校验码

- 作用：CRC 校验，可检错，不可纠错。
- **CRC** 的编码方法是：在 `k` 位信息码之后拼接 `r` 位校验码。应用 CRC 码的关键是如何从 `k` 位信息位简便地得到 `r` 位校验位（编码），以及如何从 `k+r` 位信息码判断是否出错。
- 把接收到的 CRC 码用约定的生成多项式 G(X) 去除（模二除法），如果正确，则余数为 `0`；如果某一位出错，则余数不为 `0`。不同的位数出错其余数不同，余数和出错位序号之间有唯一的对应关系。

#### 模二除法

模二除法是指在做除法运算的过程中，不计其进位的除法 → **不需要借位**，而**将两个位进行异或运算**。

> 考点：模二除法是属于循环冗余校验码。

#### CRC 循环冗余校验码例题

**题目 1（了解）**：原始报文为 `10111`，其生成多项式为：`G(x) = x^4 + x + 1`，对其进行 CRC 编码后的结果为？（`101111100`）

```txt
第 1 步：对多项式进行拆解，得到二进制，作为模二除法的被除数

G(x) = x^4 + x + 1 → x^4 + 0 * x^3 + 0 * x^2 + x + 1 → 10011

第 2 步：在原始报文末尾加上 4 个零（G(x) 的最大次幂）→ 101110000

            1001
10011 / 101110000
        10011
        ---------
        001000000
          10011
        ---------
             1100

第 3 步：用余数替换第 2 步末尾的 4 个零，结果：101111100
```

**题目 2**：在（ D ）校验方法中，采用模2运算来构造校验位。

1. A. 水平奇偶
2. B. 垂直奇偶
3. C. 海明码
4. D. 循环冗余

### 5.4 海明校验码

- 作用：海明校验，可检错，也可纠错。
- **海明校验码**的原理是：在有效信息位中加入几个校验位形成海明码，使码距比较均匀地拉大，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错误，还能指出错误的位置，为自动纠错提供了依据。
- 特点：在信息中穿插校验位。
- 校验位个数公式（取 2 的最小值）：`2^r ≥ m + r + 1`
  - `m`：数据位（信息位）
  - `r`：校验位
- 校验位的位置：`2^0` ~ `2^(r-1)`。

**题目 1**：求信息 `1011` 的海明码。

```txt
(1) 由公式：2^r ≥ 4 + r + 1 确定校验码为 3 位；
    分别放在：2^0 ~ 2^1 ~ 2^2
(2) 列出校验位公式：
    I4 → 7 = 2^2 + 2^1 + 2^0
    I3 → 6 = 2^2 + 2^1
    I2 → 5 = 2^2 + 2^0
    I1 → 3 = 2^1 + 2^0

    r2 = I4 ⊕ I3 ⊕ I2
    r1 = I4 ⊕ I3 ⊕ I1
    r0 = I4 ⊕ I2 ⊕ I1
(3) 代入 `1011` 结合公式得
    r2 = 0
    r1 = 0
    r0 = 1
```

最终结果如表格所示：

|   7   |   6   |   5   |   4   |   3   |   2   |   1   |       位数       |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :--------------: |
|  I4   |  I3   |  I2   |       |  I1   |       |       |      信息位      |
|       |       |       |  r2   |       |  r1   |  r0   |      校验位      |
|   1   |   0   |   1   |  r2   |   1   |  r1   |  r0   | 海明码（计算前） |
|   1   |   0   |   1   |   0   |   1   |   0   |   1   | 海明码（计算后） |

### 5.5 校验码小结

|                  | 校验码位数         | 校验码位置       | 检错       | 纠错     | 校验方式                                                 |
| ---------------- | ------------------ | ---------------- | ---------- | -------- | -------------------------------------------------------- |
| 奇偶校验         | 1                  | 一般拼接在头部   | 奇数位错误 | 不可纠错 | 奇校验：最终 1 的个数是奇数；偶校验：最终 1 的个数是偶数 |
| CRC 循环冗余校验 | 多项式最高次幂决定 | 拼接在信息位尾部 | 可检错     | 不可纠错 | 模二除法求余数，拼接作为校验位                           |
| 海明校验         | `2^r ≥ m + r + 1`  | 插在信息位中间   | 可检错     | 可纠错   | 分组奇偶校验                                             |

## 6. 计算机结构
